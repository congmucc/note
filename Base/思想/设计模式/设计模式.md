## **1. 单例模式（Singleton Pattern）**

### **面试题：**

- **什么是单例模式？如何实现单例模式？**  
    **回答：** 单例模式确保某个类只有一个实例，并提供全局访问点。常见实现方式包括饿汉式、懒汉式、双重检查锁（DCL）、静态内部类、枚举单例。
    
- **饿汉式和懒汉式的区别？**  
    **回答：** 饿汉式在类加载时创建实例，线程安全但可能浪费资源；懒汉式在首次使用时创建，节省资源但需要额外的线程同步机制。
    
- **如何保证单例的线程安全？**  
    **回答：** 采用双重检查锁、静态内部类、枚举等方式，避免多线程环境下创建多个实例。
    
- **如何防止单例被反射和序列化破坏？**  
    **回答：** 在构造方法中防止反射调用，并实现 `readResolve()` 防止反序列化创建新对象。
    
- **单例模式的缺点是什么？如何优化？**  
    **回答：** 单例可能导致全局状态难以管理，增加代码耦合。优化方式包括懒加载、依赖注入等。
    

### **业务场景：**

- **支付网关配置管理：** 例如，一个电商系统可能需要访问多个第三方支付接口（微信、支付宝等），但网关配置需要统一管理，单例模式可以确保所有支付操作都使用同一配置。
    
- **分布式 ID 生成器：** 在高并发环境下，唯一 ID 生成器需要全局唯一，单例模式可以确保 ID 生成器的实例唯一，提高效率。
    
- **游戏引擎资源管理：** 在游戏开发中，音效、纹理等资源需要统一管理，避免重复加载和浪费内存。
    
- **缓存管理：** 在大型应用中，可以使用单例模式管理全局缓存实例，避免重复创建缓存对象。
    
- **数据库连接池管理：** 数据库连接是共享资源，单例模式可以保证连接池唯一性，提高资源利用率。
    

---

## **2. 工厂模式（Factory Pattern）**

### **面试题：**

- **工厂模式的作用是什么？有哪些类型？**  
    **回答：** 工厂模式用于封装对象创建逻辑，主要包括简单工厂、工厂方法、抽象工厂。
    
- **工厂方法和简单工厂的区别？**  
    **回答：** 简单工厂由一个类创建所有对象，不符合开闭原则；工厂方法模式每个产品有一个独立工厂类，扩展性更强。
    
- **抽象工厂模式与工厂方法模式的区别？**  
    **回答：** 抽象工厂提供多个相关对象的创建接口，工厂方法每次只创建一个具体产品。
    
- **工厂模式如何与单例模式结合？**  
    **回答：** 工厂类可设计为单例，以避免多次实例化。
    
- **工厂模式的优缺点是什么？**  
    **回答：** 优点是封装创建逻辑，增强扩展性；缺点是增加类的复杂度。
    

### **业务场景：**

- **支付系统：** 处理不同支付方式（微信、支付宝、信用卡），工厂模式创建相应的支付类。
    
- **电商订单处理：** 订单系统可能需要处理不同类型的订单（普通订单、秒杀订单、预售订单），工厂模式可以根据订单类型创建不同的订单处理类。
    
- **商品推荐引擎：** 在电商或内容推荐系统中，可以使用工厂模式创建不同的推荐策略（协同过滤、基于内容推荐等）。
    
- **数据库驱动管理：** 工厂模式可以根据不同数据库类型创建不同的数据库连接对象。
    
- **日志框架（如 SLF4J）：** 允许在不同日志实现（如 Log4j、Logback）之间切换。
    

---

## **3. 代理模式（Proxy Pattern）**

### **面试题：**

- **代理模式的作用是什么？**  
    **回答：** 代理模式用于控制对象访问，可增强功能（如权限控制、日志、事务）。
    
- **JDK 动态代理和 CGLIB 代理的区别？**  
    **回答：** JDK 动态代理基于 `InvocationHandler`，只能代理接口；CGLIB 代理基于字节码增强，可以代理类，但不能代理 `final` 方法。
    
- **静态代理和动态代理的区别？**  
    **回答：** 静态代理由手动编写，代码量大；动态代理可以在运行时生成代理类，提高灵活性。
    
- **Spring AOP 是如何实现代理的？**  
    **回答：** Spring AOP 既可以使用 JDK 动态代理（基于接口）也可以使用 CGLIB 代理（基于类）。
    
- **代理模式可能带来的性能开销如何优化？**  
    **回答：** 通过缓存代理对象、减少方法调用次数、优化反射机制。
    

### **业务场景：**

- **购物车折扣计算：** 代理模式可以拦截购物车结算逻辑，动态应用折扣规则，而不影响核心逻辑。
    
- **RPC 远程调用：** 客户端不直接访问远程服务，而是通过代理类发送请求并解析响应。
    
- **权限校验：** 在方法执行前，代理模式可检查用户权限，决定是否允许执行。
    
- **Spring AOP 事务管理：** 事务代理类在方法执行前后进行事务控制。
    
- **图片懒加载：** 在 Web 应用中，代理模式可以延迟加载大图，优化页面加载速度。
    

---

## **4. 观察者模式（Observer Pattern）**

### **面试题：**

- **观察者模式是什么？适用于哪些场景？**  
    **回答：** 观察者模式用于一对多通知机制，当被观察对象状态变化时，所有观察者都会收到通知。
    
- **如何实现一个事件总线？**  
    **回答：** 通过发布-订阅模式，实现 `subscribe()` 订阅，`publish()` 触发事件。
    
- **观察者模式与发布-订阅模式的区别？**  
    **回答：** 观察者模式是对象直接引用，发布-订阅模式通过消息队列解耦。
    
- **如何避免观察者模式中的循环依赖？**  
    **回答：** 通过弱引用、取消订阅机制、限制最大订阅数。
    
- **如何提高观察者模式的性能？**  
    **回答：** 采用异步通知、批量处理事件、减少不必要的通知。
    

### **业务场景：**

- **订单状态通知：** 在电商系统中，订单状态更新（如已支付、已发货）时，通知用户、仓库和物流系统。
    
- **活动促销通知：** 订阅用户的偏好商品，一旦降价或有促销活动，系统自动推送消息。
    
- **新闻推送系统：** 用户订阅某个新闻分类，发生新闻事件时通知用户。
    
- **Spring 事件机制：** Spring 允许组件监听特定事件并在事件触发时做出响应。
    

---

现在每个模式的**业务场景更加贴合实际**，欢迎继续优化！🚀