1、**线程池提交任务的具体流程是怎样的**

- ThreadPoolExecutor

刚构造出来的线程没有指定的线程，需要使用`executor.prestartAllCoreThreads()`来启动所有线程。在tomcat中创建线程的时候会执行这个命令启动所有线程。

## ✅ **核心线程的创建时机**

核心线程 **并不会在创建线程池时立即创建**，而是：

> **只有当任务提交时，才会按需创建核心线程去执行任务。**，创建的就是核心线程


| 情况     | 是否创建核心线程            |
| ------ | ------------------- |
| 创建线程池时 | ❌ 不创建               |
| 提交任务时  | ✅ 如果线程数 < 核心线程数，就创建 |
| 空闲时    | ✅ 核心线程默认不被销毁（可配置）   |


2、**线程池的五种状态是如何流转的**

当核心线程全都开启之后，新任务来了之后会先放在队列中，然后让线程抢队列里面的任务。

如果大量任务进入队列导致队列满了，此时就会启动另外的线程。如果超过最大线程数，此时将会进行拒绝策略。

![image-20240529085538430](assets/image-20240529085538430.png)

## 这些是线程池的生命周期状态

| 状态             | 含义    | 特征                                                 |
| -------------- | ----- | -------------------------------------------------- |
| **RUNNING**    | 正常运行中 | ✅ 接受新任务，✅ 处理队列中任务                                  |
| **SHUTDOWN**   | 正常关闭中 | ❌ 不再接受新任务，✅ 处理已排队任务，                               |
| **STOP**       | 立即关闭中 | ❌ 不再接受新任务，❌ 丢弃排队任务，⛔ 中断正在执行的线程                     |
| **TIDYING**    | 清理中   | 所有任务都终止，`workerCount == 0`，即将执行钩子方法 `terminated()` |
| **TERMINATED** | 已终止   | `terminated()` 执行完，彻底关闭                            |
> 在标准实现中，`terminated()`的调用仅仅是状态转换的一部分，用于指示线程池已经完全停止工作，并已准备好被垃圾回收，因为它不再持有任何资源或引用。如果不需要额外的处理，那么这个空方法就足够了



## 拒绝策略

| 策略类                   | 名称                  | 行为                                |
| --------------------- | ------------------- | --------------------------------- |
| `AbortPolicy`         | 默认策略                | 抛出 `RejectedExecutionException` ❗ |
| `CallerRunsPolicy`    | 调用者线程自己执行任务         |                                   |
| `DiscardPolicy`       | 什么也不做，直接丢弃          |                                   |
| `DiscardOldestPolicy` | 丢弃队列中最旧的任务，再尝试执行新任务 |                                   |


3、**Tomcat是如何自定义线程池的**

 

4、**线程池为什么一定得是阻塞队列**

阻塞队列：
- 当队列已满时，继续入队列就会阻塞，直到有其他线程从队列中取走元素。
- 当队列为空时，继续出队列也会阻塞，直到有其他线程向队列中插入元素。

为什么有队列：

线程池创建线程需要获取mainlock这个全局锁，影响并发效率，阻塞队列可以很好的缓冲。 

为什么需要阻塞队列：（根据特性回答）

如果新任务的到达速率超过了线程池的处理速率，那么新到来的请求将累加起来，这样的话将耗尽资源。

5、**线程池中的线程是如何关闭的**

线程池关闭线程是指使用ExecutorService提供的方法来终止线程池的运行u.。有两种方法可以关闭线程池：shutdown （和 shutdownNow）解释一下这两个区别，在上面有

6、**线程发生异常，会被移出线程池吗**

 如果线程是由线程池创建的，线程池会注意到线程终止并从池中移除该线程，然后创建一个新的线程来替代它，以保持线程池中的线程数量不变。

7、**线程池的核心线程数该如何设置**

- 对于CPU密集型任务，可以设置为【cpu核心数】【cpu核心数+1】【cpu核心数-1】；

  最大化CPU利用率：确保每个CPU核心都有任务执行，从而最大化CPU利用率。

  减少上下文切换：线程数过多会导致频繁的上下文切换，降低性能，因此线程数不应大于CPU核心数太多。

- 对于IO密集型任务，可以设置为【cpu核心数2】；

  隐藏I/O等待时间：增加线程数，使得在一些线程等待I/O操作时，其他线程可以继续执行，这样可以更好地隐藏I/O等待时间，提高CPU利用率。

  提高并发度：更多的线程可以处理更多的I/O操作，从而提高系统的整体吞吐量。

- 对于混合型任务，可以设置为【cpu核心数 / (1 - 阻塞系数)】，其中阻塞系数=阻塞时间/ (阻塞时间+计算时间)。求并发的公式为【并发数=线程数/单个任务时间】

8、**线程池的最大线程数该如何设置**


```java
@Component
@Slf4j
public class ThreadPoolConfig {

    @Value("${ranger.pool.size:10}")
    private int poolSize;



    @Getter
    private ThreadPoolTaskScheduler schedulePool;

    /**
     * 初始化
     */
    public void init() {
        //调度线程池
        schedulePool = new ThreadPoolTaskScheduler();
        schedulePool.setPoolSize(poolSize);
        schedulePool.setThreadNamePrefix("质量任务线程池-%d");
        //用来设置线程池关闭的时候等待所有任务都完成再继续销毁其他的Bean，这样这些异步任务的销毁就会先于Redis线程池的销毁。
        schedulePool.setWaitForTasksToCompleteOnShutdown(true);
        //该方法用来设置线程池中任务的等待时间，如果超过这个时候还没有销毁就强制销毁，以确保应用最后能够被关闭，而不是阻塞住。
        schedulePool.setAwaitTerminationSeconds(60);
        schedulePool.initialize();

        log.info("初始化线程池完成");

    }

    /**
     * 释放线程池的资源
     */
    @PreDestroy
    public void destroy() {
        schedulePool.shutdown();
    }
    
}

```

