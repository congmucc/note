在面试中，设计模式是一个重要的考察点，以下是一些**常见的设计模式面试题**，并附上简要回答和示例代码。

---

## **1. 单例模式（Singleton Pattern）**

### **面试题：**

1. **什么是单例模式？如何实现单例模式？**
    
2. **饿汉式和懒汉式单例的区别？**
    
3. **如何保证单例的线程安全？**
    
4. **如何防止反射和序列化破坏单例？**
    

### **简要回答：**

- **单例模式** 确保一个类只有**一个实例**，并提供一个全局访问点。
    
- **懒汉式（Lazy Initialization）**：在**第一次使用**时创建实例，但需要**加锁**确保线程安全。
    
- **饿汉式（Eager Initialization）**：类加载时直接创建实例，线程安全但可能**浪费资源**。
    
- **防止反射破坏**：在构造方法里**检测实例是否已存在**。
    
- **防止序列化破坏**：重写 `readResolve()` 方法，返回**已存在的实例**。
    

### **示例代码（懒汉式 + 双重检查锁）**

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {} // 私有构造方法，防止外部实例化

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

---

## **2. 工厂模式（Factory Pattern）**

### **面试题：**

1. **工厂模式的作用是什么？**
    
2. **工厂模式和简单工厂模式的区别？**
    
3. **抽象工厂和工厂方法的区别？**
    

### **简要回答：**

- **工厂模式** 用于**封装对象创建逻辑**，提高**解耦性**。
    
- **简单工厂模式**（Static Factory）：**一个工厂类**负责创建所有对象。
    
- **工厂方法模式**：每个子类实现**自己的工厂方法**，更符合**开闭原则**（OCP）。
    
- **抽象工厂模式**：提供**多个工厂方法**，适用于**产品族**（如不同品牌的手机和电脑）。
    

### **示例代码（工厂方法模式）**

```java
// 抽象产品
interface Product {
    void use();
}

// 具体产品 A
class ProductA implements Product {
    public void use() { System.out.println("使用产品 A"); }
}

// 工厂接口
interface Factory {
    Product createProduct();
}

// 具体工厂 A
class FactoryA implements Factory {
    public Product createProduct() { return new ProductA(); }
}

// 使用
public class FactoryMethodDemo {
    public static void main(String[] args) {
        Factory factory = new FactoryA();
        Product product = factory.createProduct();
        product.use();
    }
}
```

---

## **3. 代理模式（Proxy Pattern）**

### **面试题：**

1. **什么是代理模式？**
    
2. **静态代理 vs 动态代理的区别？**
    
3. **JDK 动态代理和 CGLIB 代理的区别？**
    

### **简要回答：**

- **代理模式** 让代理对象代替**真实对象**执行某些操作（如日志、权限控制、事务管理）。
    
- **静态代理**：编译时确定，手写代理类，**不灵活**。
    
- **JDK 动态代理**：基于 `InvocationHandler`，**只能代理接口**。
    
- **CGLIB 代理**：基于**字节码生成**，能代理**类**，比 JDK 代理更强大。
    

### **示例代码（JDK 动态代理）**

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 接口
interface Service {
    void doSomething();
}

// 真实对象
class RealService implements Service {
    public void doSomething() {
        System.out.println("执行真实业务逻辑");
    }
}

// 动态代理
class ProxyHandler implements InvocationHandler {
    private Object target;

    public ProxyHandler(Object target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("前置操作...");
        Object result = method.invoke(target, args);
        System.out.println("后置操作...");
        return result;
    }
}

// 测试代理
public class DynamicProxyDemo {
    public static void main(String[] args) {
        Service realService = new RealService();
        Service proxy = (Service) Proxy.newProxyInstance(
                realService.getClass().getClassLoader(),
                realService.getClass().getInterfaces(),
                new ProxyHandler(realService)
        );
        proxy.doSomething();
    }
}
```

---

## **4. 观察者模式（Observer Pattern）**

### **面试题：**

1. **什么是观察者模式？**
    
2. **观察者模式适用于哪些场景？**
    
3. **如何用 Java 实现观察者模式？**
    

### **简要回答：**

- **观察者模式** 让一个对象（被观察者）在状态发生变化时**自动通知多个观察者**，实现**解耦**。
    
- 适用于 **事件驱动**（如 GUI 事件、消息队列、监听模式）。
    
- Java 提供 `Observer` 和 `Observable`，但更推荐使用**自定义实现**或 **Spring 事件机制**。
    

### **示例代码**

```java
import java.util.ArrayList;
import java.util.List;

// 观察者接口
interface Observer {
    void update(String message);
}

// 具体观察者
class User implements Observer {
    private String name;
    
    public User(String name) { this.name = name; }
    
    public void update(String message) {
        System.out.println(name + " 收到通知：" + message);
    }
}

// 被观察者
class WeChatPublicAccount {
    private List<Observer> observers = new ArrayList<>();

    public void addObserver(Observer observer) { observers.add(observer); }
    public void removeObserver(Observer observer) { observers.remove(observer); }
    public void notifyObservers(String message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

// 测试
public class ObserverPatternDemo {
    public static void main(String[] args) {
        WeChatPublicAccount account = new WeChatPublicAccount();
        
        Observer user1 = new User("Alice");
        Observer user2 = new User("Bob");
        
        account.addObserver(user1);
        account.addObserver(user2);
        
        account.notifyObservers("新文章发布啦！");
    }
}
```

---

## **5. 适配器模式（Adapter Pattern）**

### **面试题：**

1. **什么是适配器模式？**
    
2. **适配器模式的应用场景？**
    
3. **类适配器 vs 对象适配器的区别？**
    

### **简要回答：**

- **适配器模式** 用于**转换接口**，让原本不兼容的类可以一起工作。
    
- 适用于 **老系统升级、库的兼容性调整**。
    
- **类适配器（继承）**：适配器继承**一个旧类**并实现**新接口**。
    
- **对象适配器（组合）**：适配器**持有一个旧类的实例**并调用其方法。
    

---

### **总结**

|**设计模式**|**作用**|**应用场景**|
|---|---|---|
|**单例模式**|确保全局唯一实例|数据库连接池、线程池|
|**工厂模式**|统一创建对象|依赖注入、日志框架|
|**代理模式**|代理对象执行任务|AOP、RPC|
|**观察者模式**|事件驱动|监听器、消息队列|
|**适配器模式**|接口转换|旧系统兼容新接口|

这些都是面试中**最常考的设计模式**，你可以重点掌握它们 🚀！