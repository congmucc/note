
- 在团队内有效协作，积极参与技术架构和解决方案的塑造，不断了解和学习新技术，并追求新兴技术。
- 了解并应用区块链技术，为 Web3 Wallet DEX 项目提供相应的开发支持。
- 推动在团队中引入创新技术和解决方案，以创新思维解决问题。

- 精通多线程编程，熟悉 JVM，了解常见的开源分布式中间件、缓存、消息队列等，擅长 MySQL 性能调优。
- 熟悉 Spring Cloud 等框架，并具备设计和稳定大规模分布式、高并发、高负载和高可用性系统的经验者优先。

- 熟练掌握 Solidity 等智能合约语言。
- 作为 Web3 开发人员的成熟经验。



[Jvm](../../后端/Java/Interview/Interview.md#^10fe41)

[mysql优化问题 + 千万级查询，深度分页](../../后端/SQL/Mysql/优化问题.md#^176b49)

[mysql 各种锁   B+树](../../后端/SQL/Mysql/面试问题.md#^96de15)

[Redis 大key 双写一致性](../../后端/SQL/Redis/Redis导学.md)

[设计模式](../../思想/设计模式/设计模式.md)


**项目有什么难度，是什么架构：**
难度：

## 公司业务
### 介绍
目前做的事一个游戏平台，
一开始做游戏吗，就按照一个游戏一个合约，之后发现开发成本太高，后面转成整成一个大合约架子，基础包含 下注，开奖，提现，自动开奖，自动下注。合约里面只存储像转账，对数据判断的一些逻辑，而不是将游戏逻辑也放进去，游戏逻辑使用后端进行代替，采用链上链下相结合进行完成的逻辑，

### **单局投注**
> 后端会有一个链监听服务，监听到事件之后将数据进行解析，使用redis推播到另一个游戏服务中，然后在游戏服务进行判断数据。之后再进行入库，并使用推播到链服务进行开奖调用。


### **单局多人游戏：**
> 单局多人游戏：在本局游戏中进行监听下注，因为这种一局多人游戏会有一个时间限制，它与合约会有一个时间差，我们对于一局游戏下注的时候要传后端生成的hash的，如果说这局游戏到了时间，下注不了。现在还有一个问题是，下注了了，但是event日志还没有进行发送出来，这时候就可能出现区块链下注完成了，但是没有开奖，以下是解决方案：

- 下注交易提交时，后端**存储交易哈希 (`txHash`)**，并用定时任务**轮询交易状态**。
- 如果交易在**游戏时间截止后**才被确认，可以在后端进行**强制退款**（或标记为无效）。
**双通道检测**：
- **事件监听方式 A**：监听 `event log`，用于**正常流程**下注确认。
- **区块数据方式 B**：定期**遍历最近的区块**，查找漏掉的下注交易。
- **如果 `event` 未出发，但交易已被确认**，则手动补充开奖数据。

结果：
- **下注提交**
    - 前端提交交易，后端存储 `txHash`。
    - 监听 `event` 以及 `JSON-RPC` 轮询状态。
- **事件监听**
    - 优先使用 `event` 触发下注确认。
    - 若 `event` 迟迟未出，则使用 `txHash` 轮询链上状态。
- **开奖逻辑**
    - 先通过 `event` 触发开奖。
    - 若 `event` 丢失，则使用 `getUserBet()` 直接读取链上状态。
- **异常处理**
    - 如果下注成功但未开奖，后端定时任务检查 `txHash` 并强制开奖。
    - 如果 `event` 丢失，回溯区块获取交易记录，手动补充开奖数据。


### **自动下注：**
下注方法 `function auto_bet(uint256 game_id, uint256 token_id, uint256 initial_amount, uint256[] auto_set, bytes32[] hashArr, bytes data) external {}`
- - game_id 游戏ID
    - token_id tokenID 0 ETH, 1 USDT, 2 USDC
    - initial_amount 第一个订单金额
    - auto_set 一共四个元素，分别是： win_limit 盈利停止;loss_limit 亏损停止;add_when_win 盈利增加; add_when_loss 亏损增加
    - hashArr 按顺序的所有订单的hash
    - data 自定义内容
自动派奖：
- game_id 游戏ID
- auto_id 自动下注的ID，每次自动下注的一批订单，合约会生成对应一个自动下注ID到链上
- seed 生成服务端hash的种子数组，数组
- rate 赔率（0的话，未中奖，大于0按照实际赔率派奖）, 这个跟费率没关，费率已经设置在合约里了，数组
- hash_expired 该订单是否有效，无效撤单，数组
> 这个自动下注就很好说了，后端自动进行下注，它有一个设置 订单金额，还有一个数组，盈利停止，亏损停止，盈利增加，亏损增加，还有一个存储所有订单hash的数组，这样可以保证一个正确性。后台自动下注，因为合约是不知道多少轮（还有一些类似像交易所的挂单这种），所以说要有一个停止的标志，每次下注之后会存储到redis和mysql，进行监听日志后再进行下一轮，因为要有交易记录，最后就是开奖，监听自动下注结束日志，然后遍历内容进行计算派奖，最后通过推播调用合约发起派奖。



### 高并发

####  一、构建多通道下注确认机制（防丢事件）

**背景问题**：

- 区块链的 `event log` 有时会延迟或者丢失；
- 如果下注事件没监听到，就没法开奖；
- 有些网络（如 Solana）在高并发时 `websocket` 的推送不一定可靠。

| 通道     | 触发条件        | 作用          |
| ------ | ----------- | ----------- |
| 事件监听   | `event`推送成功 | 主路径，正常下注流程  |
| 交易状态轮询 | event未推送/延迟 | 补偿，保证下注状态同步 |
| 区块扫描   | 长时间未处理/丢事件  | 最终补偿，兜底所有异常 |
交易状态轮询：
> - 提交下注交易时，提交到redis里面，**记录 `txHash` 和用户信息**；
> - 开启定时任务（例如每5秒）：
    - 使用 RPC 轮询该 `txHash` 的交易状态； 
    - 如果已经 **确认且成功执行**，但未收到事件，则**补录下注信息**。

区块扫描补偿机制（最终补偿）：
这个的话


#### 二、定时任务 + Redis + 事务落库（确保一致性）

**背景目标**：

- 多链下注高并发下，链上成功但链下状态未同步，会导致系统状态不一致；
- 需要可靠、可追溯、幂等的下注逻辑。



### 扫块
> 这个是用户给平台地址充值，扫块看是哪个用户充的。

####  概念：
需要scheduler（定时任务），每15秒扫一次新的块，例如之前是12345677，下一块就是12345678, 所以每扫一块就+1

如果出现扫太快就timeout/sleep 3-5秒，在扫过

如果测试服断了，先扫最新的让他正常运作，然后开一个新的scheduler来扫没扫到的块，range (例如: 12345 - 12556没扫到, 最新是12557)
#### 问题 ：用户充值到了公用地址，平台无法直接知道是哪个用户的充值
**1. BTC 采用 UTXO 模型，没有固定的 `from` 地址**
BTC 使用 **UTXO（未花费交易输出）模型**，交易的输入 (`inputs`) 可以来自多个不同的 UTXO，并且这些 UTXO 可能属于不同的地址。

**解决方案**： 
- **监控用户充值时的 UTXO 记录**，确保该输入 UTXO 属于该用户的钱包。
- 让用户先提交订单，后台监听 `txid`，匹配金额 + 地址。



### 充值业务

概念：
> 通过**HD钱包**进行生成单独用户的钱包，用户可以从一个随机种子创建一系列密钥对 
> 像BTC的[BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)（`BIP32`提出可以用一个随机种子衍生多个私钥，例如`“m/0/0/1”`。），[BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki)(升级了规范，变成6级了)，和[BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)（`BIP39`让用户能以一些人类可记忆的助记词的方式保管私钥，而不是一串16进制的数字：）。

我们的逻辑：
> 因为HD钱包的场景是多账户（钱包App）， 我们仅仅是想做个充值绑定、收款系统，所以不像hd 是有多个 key，而我们不需要那个，只需要一个 mnemonic/seed，就可以生成了，一般是在用户注册成功之后就给他们。
> 用户转完钱包之后，我们这边再进行归集。
> 
> 还有另一个方案是转成合约来收
> 

归集方案：
>我们这里使用的是维护一个地址表，后端服务订阅新区块（或定时拉取）， 拿到交易列表后，对交易的
>`to` 地址或者 input data 做比对；如果命中你分配的地址，**说明这个用户有充值**；入库、更新余额、
>通知等。
>
>还有另一个方案，用户充值的时候后端起一个线程监听对应的钱包地址，但是这个不是很好，因为这个如果用户多的话，容易崩。
>




```
m/44'/0'/0'/0/0
m/44'/0'/0'/0/1
```
> 这种是两个key，就是两个钱包



#### BIP44


`BIP44`为`BIP32`的衍生路径提供了一套通用规范，适配比特币、以太坊等多链。这一套规范包含六级，每级之间用"/"分割：

```
m / purpose' / coin_type' / account' / change / address_index
```

其中：

- m: 固定为"m"
- purpose：固定为"44"
- coin_type：代币类型，比特币主网为0，比特币测试网为1，以太坊主网为60
- account：账户索引，从0开始。
- change：是否为外部链，0为外部链，1为内部链，一般填0.
- address_index：地址索引，从0开始，想生成新地址就把这里改为1，2，3。

举个例子，以太坊的默认衍生路径为`"m/44'/60'/0'/0/0"`。

# 
您好，感谢您这边抽时间进行面试，其中看了一下岗位的需求，先说岗位需求需要java，我这边是也是没有问题的，因为我这边之前也搞过java，语言都是大差不差，关键是看思想逻辑，我在现在这家公司主要是使用golang，微服务的话使用的是fiber。




#### **1. 个人介绍（简短有力，突出核心技能）**

**候选人：**  
您好，我是ld，目前在后端开发领域有1年的经验，专注于Golang开发，同时也有一定的Java开发背景。我在区块链和Web3领域有深入的研究，特别是Solana、Ethereum、ton、base和SUI等公链，并熟悉智能合约开发，包括Foundry和Anchor框架。

在后端开发方面，我擅长微服务架构，熟练使用Gin、GoZero等Golang框架，并具备Kafka、RabbitMQ、ElasticSearch等中间件的使用经验。此外，我有数据库优化的经验，能基于MySQL、PostgreSQL和Redis进行高效的数据存储和查询优化。我在之前的工作中，参与了RBAC权限管理、系统日志框架、TOTP双因子认证等项目。

#### **2. 职业目标（展现你对未来的规划）**

我希望未来能够继续深耕Web3领域，尤其是区块链底层技术和去中心化应用的开发。我对高性能智能合约优化、链上数据分析以及Web3基础设施建设很感兴趣，希望能在一家国际化的公司中，与优秀的工程师合作，共同推动行业发展。我也希望能够在未来的角色中承担更多的架构设计和技术决策的责任，进一步提升自己的技术领导力。

#### **3. 对下一个角色的期望（展现你的需求与适配性）**

在新角色中，我希望能有机会：

- 参与高性能区块链应用的开发，深入优化智能合约和后端架构；
    
- 参与跨链交互、链上数据索引等复杂业务，提高区块链数据处理能力；
    
- 在一个有技术氛围的团队中，与优秀的工程师交流学习，提升自己的技术视野；
    
- 在后端开发之外，更多接触Web3安全、去中心化存储等领域，扩展自己的知识体系。
    

#### **4. 向面试官提问（展现你的兴趣和思考）**

**候选人：**  
我对Binance的技术栈和团队氛围很感兴趣，想请教几个问题：

- **技术栈方面**：团队主要使用哪些编程语言和框架？Golang在团队中的应用主要集中在哪些方面？
    
- **项目方向**：目前团队正在开发哪些Web3相关的项目？未来是否有计划在Solana、SUI等新兴公链上布局？
    
- **协作方式**：团队是如何进行远程协作的？日常的开发流程和工具有哪些？
    
- **职业成长**：Binance的工程师在技术成长方面有哪些支持？比如Code Review、技术分享、内部培训等？
    
- **招聘流程**：请问接下来的面试流程是怎样的？会涉及哪些技术考察方向？



哪些平台获取信息
论坛，举个例子