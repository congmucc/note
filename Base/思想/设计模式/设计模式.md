## **1. 单例模式（Singleton Pattern）**

### **面试题：**

- **什么是单例模式？如何实现单例模式？**  
    **回答：** 确保一个类只有一个实例，并提供全局访问点。常见实现包括**饿汉式、懒汉式、双重检查锁、静态内部类、枚举单例**。
    
- **饿汉式和懒汉式的区别？**  
    **回答：** 饿汉式**类加载时创建实例**，线程安全但可能浪费资源；懒汉式**首次使用时创建**，但需加锁保证线程安全。
    
- **如何防止单例被反射和序列化破坏？**  
    **回答：** 在**构造方法中防止反射调用**，并**实现 `readResolve()` 防止反序列化创建新对象**。
    
- **业务场景：**  
    **数据库连接池、日志管理、线程池管理**等需要全局唯一实例的场景。
    

---

## **2. 工厂模式（Factory Pattern）**

### **面试题：**

- **工厂模式的作用是什么？有哪些类型？**  
    **回答：** 工厂模式用于**封装对象创建逻辑**，包括**简单工厂、工厂方法、抽象工厂**。
    
- **工厂方法和简单工厂的区别？**  
    **回答：**
    - **简单工厂**：一个工厂类创建所有对象，不符合**开闭原则**。
    - **工厂方法**：每个产品有一个工厂，符合**开闭原则**，易扩展。
- **业务场景：**  
    **数据库驱动、日志框架（如 `SLF4J`）、Spring BeanFactory**等动态对象创建场景。
    

---

## **3. 代理模式（Proxy Pattern）**

### **面试题：**
- **代理模式的作用是什么？**  
    **回答：** 代理模式用于**控制对象访问**，可增强功能（如**权限控制、日志、事务**）。
- **JDK 动态代理和 CGLIB 代理的区别？**  
    **回答：**
    
    - **JDK 动态代理**：基于 **`InvocationHandler`**，**只能代理接口**。
        
    - **CGLIB 代理**：基于**字节码增强**，**可以代理类**，但不能代理 `final` 方法。
        
- **业务场景：**  
    **Spring AOP（事务、日志）、RPC 远程调用、权限校验**等场景。
    

---

## **4. 观察者模式（Observer Pattern）**

### **面试题：**

- **观察者模式是什么？适用于哪些场景？**  
    **回答：** 观察者模式用于**一对多通知机制**，当**被观察对象状态变化**时，所有观察者都会收到通知。
    
- **如何实现观察者模式？**  
    **回答：** 在 Java 中可以使用**`java.util.Observer`**（JDK 自带）或**事件驱动模式（如 `Spring Event`）**。
    
- **业务场景：**  
    **事件驱动系统、MQ 消息订阅、GUI 事件监听**等。
    

---

## **5. 适配器模式（Adapter Pattern）**

### **面试题：**

- **适配器模式的作用是什么？**  
    **回答：** 适配器模式用于**接口转换**，让不兼容的类可以一起工作，类似**电源适配器**。
    
- **适配器模式有哪些实现方式？**  
    **回答：**
    
    - **类适配器**（继承方式）
        
    - **对象适配器**（组合方式）
        
- **业务场景：**  
    **老系统对接新接口、数据库驱动适配、多种日志框架兼容**。
    

---

## **6. 策略模式（Strategy Pattern）**

### **面试题：**

- **策略模式是什么？与工厂模式的区别？**  
    **回答：** 策略模式封装多个算法，让它们可以**互相替换**。工厂模式是**创建对象**，策略模式是**行为替换**。
    
- **业务场景：**  
    **支付方式选择（微信/支付宝）、排序策略（快排/归并）、日志格式化（JSON/PlainText）**。
    

---

## **7. 充血模型和贫血模型**

### **面试题：**

- **充血模型（Rich Model）和贫血模型（Anemic Model）的区别？**  
    **回答：**
    
    |**模型**|**特点**|**优点**|**缺点**|
    |---|---|---|---|
    |**贫血模型**|业务逻辑放 `Service` 层，实体类只有 getter/setter|代码简单|逻辑分散，`Service` 变复杂|
    |**充血模型**|业务逻辑和数据都在 `Domain` 层|高内聚、符合 DDD|代码量大，学习成本高|
    
- **业务场景：**  
    **DDD 领域驱动设计、复杂业务逻辑（订单、库存管理）**采用充血模型，**简单 CRUD 系统**适合贫血模型。
    

---

## **8. DDD 领域驱动设计**

### **面试题：**

- **DDD 主要概念是什么？**  
    **回答：** DDD（Domain-Driven Design）强调**以业务领域为中心**，核心概念包括**实体（Entity）、值对象（Value Object）、聚合（Aggregate）、领域服务（Domain Service）**等。
    
- **如何在项目中实践 DDD？**  
    **回答：**
    
    - **分层架构**（应用层、领域层、基础设施层）
        
    - **使用充血模型**
        
    - **定义限界上下文（Bounded Context）**
- **业务场景：**  
    **电商订单管理、银行账户系统、复杂业务逻辑**。
    

---


---

## **总结**

|**模式**|**面试考点**|**业务场景**|
|---|---|---|
|**单例模式**|线程安全、反射/序列化攻击|数据库连接池、日志管理|
|**工厂模式**|简单工厂 vs 工厂方法|数据库驱动、日志框架|
|**代理模式**|JDK 代理 vs CGLIB|Spring AOP、RPC|
|**观察者模式**|事件驱动|MQ 消息订阅、GUI 监听|
|**适配器模式**|兼容老接口|数据库驱动、多日志兼容|
|**策略模式**|互相替换的算法|支付方式、日志格式化|
|**充血 vs 贫血**|领域逻辑放哪里？|复杂业务用充血，CRUD 用贫血|
|**DDD**|领域层概念|复杂业务建模|
|**事务隔离**|脏读、幻读|订单、库存扣减|

这样**涵盖多个设计模式，每个模式都有面试题、核心回答和业务应用**，更方便面试时使用！🚀